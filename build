#!/bin/bash
set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$PROJECT_ROOT"

source "$PROJECT_ROOT/scripts/lib/supported.sh"

check_missing() {
    local arch_filter="${1:-}"
    
    echo "Checking for missing binaries..."
    echo "================================"
    
    local expected_file="expected.txt"
    if [ ! -f "$expected_file" ]; then
        echo "Generating expected binaries list from x86_64..."
        if [ -d "output/x86_64" ]; then
            find output/x86_64 -type f -executable 2>/dev/null | sed 's|output/x86_64/||' | sort > "$expected_file"
        else
            echo "Error: No x86_64 output directory to generate expected list from"
            echo "Build x86_64 first: ./build --arch x86_64"
            return 1
        fi
    fi
    
    local total_expected=$(wc -l < "$expected_file")
    
    local archs_to_check=()
    if [ -n "$arch_filter" ]; then
        if [ -d "output/$arch_filter" ]; then
            archs_to_check=("$arch_filter")
        else
            for arch_dir in output/*/; do
                if [ -d "$arch_dir" ]; then
                    arch=$(basename "$arch_dir")
                    if [[ "$arch" == *"$arch_filter"* ]]; then
                        archs_to_check+=("$arch")
                    fi
                fi
            done
        fi
    else
        for arch_dir in output/*/; do
            if [ -d "$arch_dir" ]; then
                arch=$(basename "$arch_dir")
                archs_to_check+=("$arch")
            fi
        done
    fi
    
    if [ ${#archs_to_check[@]} -gt 0 ]; then
        IFS=$'\n' archs_to_check=($(sort <<<"${archs_to_check[*]}"))
        unset IFS
    fi
    
    if [ ${#archs_to_check[@]} -eq 0 ]; then
        echo "No output directories found"
        if [ -n "$arch_filter" ]; then
            echo "No architectures matching filter: $arch_filter"
        fi
        return 1
    fi
    
    local overall_missing=0
    local overall_existing=0
    
    for arch in "${archs_to_check[@]}"; do
        local arch_missing=()
        local arch_existing=()
        
        while IFS= read -r binary; do
            if [ -f "output/$arch/$binary" ]; then
                arch_existing+=("$(basename "$binary")")
            else
                arch_missing+=("$(basename "$binary")")
            fi
        done < "$expected_file"
        
        local arch_existing_count=${#arch_existing[@]}
        local arch_missing_count=${#arch_missing[@]}
        overall_existing=$((overall_existing + arch_existing_count))
        overall_missing=$((overall_missing + arch_missing_count))
        
        if [ $arch_missing_count -gt 0 ] || [ "$arch_filter" = "$arch" ]; then
            echo ""
            echo "$arch: $arch_existing_count/$total_expected built ($(( arch_existing_count * 100 / total_expected ))%)"
            
            if [ $arch_missing_count -gt 0 ]; then
                echo "  Missing:"
                local missing_tools=()
                local missing_can=()
                local missing_shell=()
                
                for binary in "${arch_missing[@]}"; do
                    case "$binary" in
                        bcmserver|canbusload|can-calc-bit-timing|candump|canfdtest|cangen|canlogserver|canplayer|cansend|isotpdump|isotprecv|isotpsend|j1939*|mcp251xfd-dump|slcan*|testj1939)
                            missing_can+=("$binary")
                            ;;
                        shell-bind|shell-env|shell-fifo|shell-helper|shell-loader|shell-reverse)
                            missing_shell+=("$binary")
                            ;;
                        *)
                            missing_tools+=("$binary")
                            ;;
                    esac
                done
                
                if [ ${#missing_tools[@]} -gt 0 ]; then
                    echo "    Tools: ${missing_tools[*]}"
                fi
                if [ ${#missing_can[@]} -gt 0 ]; then
                    echo "    CAN utils: ${missing_can[*]}"
                fi
                if [ ${#missing_shell[@]} -gt 0 ]; then
                    echo "    Shell: ${missing_shell[*]}"
                fi
            else
                echo "  ✓ All binaries built!"
            fi
        fi
    done
    
    local total_binaries=$((overall_existing + overall_missing))
    echo ""
    echo "================================"
    echo "Summary:"
    echo "  Architectures checked: ${#archs_to_check[@]}"
    echo "  Expected binaries per arch: $total_expected"
    echo "  Total binaries checked: $total_binaries"
    if [ $total_binaries -gt 0 ]; then
        echo "  Built: $overall_existing ($(( overall_existing * 100 / total_binaries ))%)"
        echo "  Missing: $overall_missing ($(( overall_missing * 100 / total_binaries ))%)"
    fi
    
    if [ $overall_missing -eq 0 ]; then
        echo ""
        echo "✓ All binaries are built for selected architectures!"
    else
        echo ""
        echo "To build missing binaries:"
        if [ -n "$arch_filter" ]; then
            echo "  ./build --arch $arch_filter"
        else
            echo "  ./build all"
        fi
    fi
    
    return 0
}

show_banner() {
    if [ -t 1 ]; then  # Only show banner if running in terminal
        echo "            )           \\     /          ("
        echo "          /|\\          ) \\___/ (         /|\\"
        echo "        /  |  \\       ( /\\   /\\ )      /  |  \\"
        echo "      /    |    \\      \\ x | O /     /    |    \\"
        echo "+----/-----|-----O------\\  |  /----O------|------\\--------+"
        echo "|                 '^'      V     '^'                      |"
        echo "|               STHENOS EMBEDDED TOOLKIT                  |"
        echo "|                  Static Binary Builder                  |"
        echo "|            Cross-Compilation for All Architectures      |"
        echo "+---------------------------------------------------------+"
        echo "  l     /\\     /         \\\\             \\     /\\     l"
        echo "  l  /     \\ /            ))              \\ /     \\  l"
        echo "   I/       V            //                V       \\I"
        echo "                         V"
        echo ""
    fi
}

TOOLS="all"
ARCHITECTURES="all"
DEBUG=""
DOWNLOAD_ONLY=false
CLEAN=false
INTERACTIVE=false
CHECK_MISSING=false
SHAREDLIB_MODE=false
SHAREDLIB_NAME=""
# LIBC_TYPE is now set via --libc flag, defaults to unset (builds both)
BUILD_MODE=""  # Build mode for static builds (standard, embedded, minimal)
FORCE_REBUILD=false

run_in_container() {
    local command="$1"
    local interactive="${2:-false}"
    local work_dir="${3:-/build}"
    local extra_mounts="${4:-}"  # Additional mounts as a string
    
    local tty_flags=""
    if [ "$interactive" = "true" ] || ([ -z "$command" ] && [ -t 0 ]); then
        tty_flags="-it"
    fi
    
    mkdir -p "${PWD}/output" "${PWD}/logs"
    
    local mounts=(
        "-v" "${PWD}/scripts:/build/scripts:ro"
        "-v" "${PWD}/output:/build/output"
        "-v" "${PWD}/logs:/build/logs"
        "-v" "${PWD}/patches:/build/patches:ro"
    )
    
    if [ -d "${PWD}/shared-libs" ]; then
        mounts+=("-v" "${PWD}/shared-libs:/build/shared-libs:ro")
    fi
    
    if [ -d "${PWD}/example-custom-tool" ]; then
        mounts+=("-v" "${PWD}/example-custom-tool:/build/example-custom-tool:ro")
    fi
    
    if [ -d "${PWD}/example-custom-lib" ]; then
        mounts+=("-v" "${PWD}/example-custom-lib:/build/example-custom-lib:ro")
    fi
    
    mounts+=(
        "-v" "sources-cache:/build/sources"
        "-v" "toolchains-cache:/build/toolchains"
        "-v" "toolchain-musl:/build/toolchains-musl"
        "-v" "toolchain-glibc:/build/toolchains-glibc"
        "-v" "deps-cache:/build/deps-cache"
    )
    
    
    local skip_exists="true"
    if [ "$FORCE_REBUILD" = "true" ]; then
        skip_exists="false"
    elif [ -n "${SKIP_IF_EXISTS:-}" ]; then
        skip_exists="$SKIP_IF_EXISTS"
    fi
    
    local env_vars=(
        "-e" "DEBUG=${DEBUG:-}"
        "-e" "SKIP_IF_EXISTS=$skip_exists"
        "-e" "BASE_DIR=/build"
        "-e" "STATIC_SCRIPT_DIR=/build/scripts/static"
    )
    
    if [ -n "${LIBC_TYPE:-}" ]; then
        env_vars+=("-e" "LIBC_TYPE=$LIBC_TYPE")
    fi
    
    # LIBC_TYPE is already added to env_vars if set
    
    if [ -n "${DEBUG_FLAGS:-}" ]; then
        env_vars+=($DEBUG_FLAGS)
    fi
    
    if ! docker image inspect sthenos-builder >/dev/null 2>&1; then
        echo "Building Docker image..."
        docker build -t sthenos-builder .
    fi
    
    if [ "$interactive" = "true" ] && [ -z "$command" ]; then
        exec docker run --rm $tty_flags \
            "${mounts[@]}" \
            "${env_vars[@]}" \
            -w "$work_dir" \
            sthenos-builder \
            /bin/bash
    else
        exec docker run --rm $tty_flags \
            "${mounts[@]}" \
            "${env_vars[@]}" \
            -w "$work_dir" \
            sthenos-builder \
            bash -c "$command"
    fi
}

SKIP_NEXT=false
for i in $(seq 1 $#); do
    if [ "$SKIP_NEXT" = true ]; then
        SKIP_NEXT=false
        continue
    fi
    
    if [ "$SKIP_REMAINING" = true ]; then
        break
    fi
    
    arg="${!i}"
    case $arg in
        --arch=*)
            ARCHITECTURES="${arg#*=}"
            ;;
        --arch)
            next_idx=$((i + 1))
            if [ $next_idx -le $# ]; then
                ARCHITECTURES="${!next_idx}"
                SKIP_NEXT=true
            fi
            ;;
        -d|--debug)
            DEBUG="1"
            ;;
        -f|--force)
            FORCE_REBUILD=true
            ;;
        --download)
            DOWNLOAD_ONLY=true
            ;;
        --clean)
            CLEAN=true
            ;;
        --clear-deps)
            CLEAR_DEPS=true
            ;;
        --clear-tools)
            CLEAR_TOOLS=true
            ;;
        -i|--interactive)
            INTERACTIVE=true
            ;;
        --no-shared)
            NO_SHARED=true
            ;;
        --shell)
            SHELL_CMD=true
            SKIP_REMAINING=true
            ;;
        --libc)
            next_idx=$((i + 1))
            if [ $next_idx -le $# ]; then
                LIBC_VALUE="${!next_idx}"
                # Validate libc type
                if [ "$LIBC_VALUE" != "musl" ] && [ "$LIBC_VALUE" != "glibc" ]; then
                    echo "Error: Invalid libc type '$LIBC_VALUE'. Must be 'musl' or 'glibc'."
                    exit 1
                fi
                LIBC_TYPE="$LIBC_VALUE"
                SKIP_NEXT=true
            else
                echo "Error: --libc requires a value (musl or glibc)"
                exit 1
            fi
            ;;
        -m|--mode)
            next_idx=$((i + 1))
            if [ $next_idx -le $# ]; then
                MODE_VALUE="${!next_idx}"
                # Validate build mode
                if [ "$MODE_VALUE" != "parallel" ] && [ "$MODE_VALUE" != "sequential" ]; then
                    echo "Error: Invalid mode '$MODE_VALUE'. Must be 'parallel' or 'sequential'."
                    exit 1
                fi
                BUILD_MODE="$MODE_VALUE"
                SKIP_NEXT=true
            else
                echo "Error: --mode requires a value (parallel or sequential)"
                exit 1
            fi
            ;;
        --check-missing)
            CHECK_MISSING=true
            next_idx=$((i + 1))
            if [ $next_idx -le $# ]; then
                next_arg="${!next_idx}"
                if [[ ! "$next_arg" =~ ^- ]]; then
                    ARCHITECTURES="$next_arg"
                    SKIP_NEXT=true
                fi
            fi
            ;;
        --help|-h)
            echo "Usage: $0 [TOOL] [OPTIONS]"
            echo ""
            echo "Build static binaries for embedded systems."
            echo ""
            echo "TOOL:"
            echo "  all         Build all tools (default)"
            echo "  strace      System call tracer"
            echo "  busybox     Multi-call binary with Unix utilities"
            echo "  busybox_nodrop  BusyBox variant that maintains SUID privileges"
            echo "  bash        Bourne Again Shell"
            echo "  socat       Socket relay tool (without SSL)"
            echo "  socat-ssl   Socket relay tool (with OpenSSL)"
            echo "  ncat        Network utility (without SSL)"
            echo "  ncat-ssl    Network utility (with OpenSSL)"
            echo "  tcpdump     Network packet analyzer"
            echo "  gdbserver   Remote debugging server"
            echo "  nmap        Network exploration and security auditing"
            echo "  dropbear    Lightweight SSH server/client (includes scp)"
            echo "  ltrace      Library call tracer (glibc-based)"
            echo "  ply         Dynamic tracer using BPF (limited arch support, LE only)"
            echo "  can-utils   CAN bus utilities (candump, cansend, etc.)"
            echo "  curl        HTTP/HTTPS client (minimal build)"
            echo "  curl-full   HTTP/HTTPS client with all protocols (FTP, LDAP, etc.)"
            echo "  microsocks  Lightweight SOCKS5 proxy server"
            echo "  shell       Shell utilities as static executables (output/<arch>/shell/)"
            echo "  custom      Custom tool template (musl, modify scripts/tools/build-custom.sh)"            
            echo ""
            echo "SHARED LIBRARIES (LD_PRELOAD):"
            echo "  libshells   All shell libraries (bind, reverse, env, fifo, helper)"
            echo "  libdesock   Socket desocketing library"
            echo "  libtlsnoverify TLS verification bypass library"
            echo "  libcustom   Custom library template (prints info at load)"
            echo ""
            echo "OPTIONS:"
            echo "  --arch ARCH      Build for specific architecture only"
            echo "  --arch all       Build for all architectures (default)"
            echo "  -d, --debug      Debug mode (verbose output)"
            echo "  -f, --force      Force rebuild (ignore existing binaries)"
            echo "  -m, --mode MODE  Build mode: standard (default), embedded, minimal"
            echo "  -i, --interactive  Launch interactive shell in build container"
            echo "  --no-shared      Skip building shared libraries (built by default)"
            echo "  --shell CMD      Run command in container with build environment"
            echo "  --download       Download sources and toolchains only"
            echo "  --clean          Clean output and logs directories"
            echo "  --clear-deps     Clear dependencies cache volume"
            echo "  --clear-tools    Clear toolchains, sources, and dependencies caches"
            echo "  --check-missing [ARCH]  Check for missing binaries (optionally filter by arch)"
            echo "  --libc TYPE      For shared libs: musl or glibc"
            echo ""
            echo "ARCHITECTURES:"
            echo "  ARM 32-bit: arm32v5le arm32v5lehf arm32v7le arm32v7lehf"
            echo "              armeb armv6 armv7m armv7r"
            echo "  ARM 64-bit: aarch64 aarch64_be"
            echo "  x86 32-bit: i486 ix86le (i686)"
            echo "  x86 64-bit: x86_64"
            echo "  MIPS 32-bit: mips32le mips32be mipsn32 mipsn32el"
            echo "  MIPS 64-bit: mips64 mips64le mips64n32 mips64n32el"
            echo "  PowerPC: ppc32be ppc32le ppc64be ppc64le"
            echo "  SuperH: sh2 sh2eb sh4 sh4eb"
            echo "  Others: microblaze microblazeel or1k m68k s390x"
            echo "  RISC-V: riscv32 riscv64"
            echo ""
            echo "EXAMPLES:"
            echo "  $0                       # Build all tools & shared libs for all architectures"
            echo "  $0 strace                # Build strace for all architectures"
            echo "  $0 --arch x86_64         # Build all tools & shared libs for x86_64"
            echo "  $0 strace --arch x86_64  # Build strace for x86_64 only"
            echo "  $0 -f strace --arch x86_64  # Force rebuild strace for x86_64"
            echo "  $0 --no-shared           # Build only static tools, skip shared libs"
            echo "  $0 libshells --arch x86_64 # Build shell libraries for x86_64"
            echo "  $0 libdesock --libc musl  # Build libdesock for all archs (musl)"
            exit 0
            ;;
        libcustom|libshells|libdesock|libtlsnoverify)
            SHAREDLIB_MODE=true
            SHAREDLIB_NAME="$arg"
            ;;
        all)
            ;;
        *)
            if [[ -n "${TOOL_SCRIPTS[$arg]+x}" ]]; then
                TOOLS="$arg"
            elif printf '%s\n' "${SUPPORTED_ARCHS[@]}" | grep -q "^$arg$"; then
                ARCHITECTURES="$arg"
            else
                echo "Error: Invalid argument '$arg'"
                echo ""
                exec "$0" --help
            fi
            ;;
    esac
done

if [ "$SHELL_CMD" = true ]; then
    SHELL_COMMAND=""
    shell_found=false
    for arg in "$@"; do
        if [ "$shell_found" = true ]; then
            if [ -z "$SHELL_COMMAND" ]; then
                SHELL_COMMAND="$arg"
            else
                SHELL_COMMAND="$SHELL_COMMAND $arg"
            fi
        elif [ "$arg" = "--shell" ]; then
            shell_found=true
        fi
    done
fi

if [ "$CHECK_MISSING" != true ] && [ -n "$ARCHITECTURES" ] && [ "$ARCHITECTURES" != "all" ]; then
    valid=false
    for valid_arch in "${SUPPORTED_ARCHS[@]}"; do
        if [ "$ARCHITECTURES" = "$valid_arch" ]; then
            valid=true
            break
        fi
    done
    
    if [ "$valid" = false ]; then
        echo "Error: Invalid architecture '$ARCHITECTURES'"
        echo ""
        echo "Valid architectures are:"
        printf '%s\n' "${SUPPORTED_ARCHS[@]}" | sort | column
        exit 1
    fi
fi

if [ "$INTERACTIVE" != true ] && [ "$CLEAN" != true ] && [ "$DOWNLOAD_ONLY" != true ] && [ "$SHELL_CMD" != true ]; then
    show_banner
fi

echo "Start time: $(date)"
echo

if [ "$CHECK_MISSING" = true ]; then
    if [ "$ARCHITECTURES" = "all" ]; then
        check_missing ""
    else
        check_missing "$ARCHITECTURES"
    fi
    exit $?
fi

if [ "$CLEAN" = true ]; then
    echo "Cleaning output and logs directories..."
    run_in_container "rm -rf /build/output/* /build/logs/* && echo 'Clean complete!'"
    echo "- Removed all files from output/"
    echo "- Removed all files from logs/"
    exit 0
fi

if [ "$CLEAR_DEPS" = true ]; then
    echo "Clearing dependencies cache..."
    run_in_container "rm -rf /build/deps-cache/* && echo '✓ Cleared dependencies cache' || echo '✗ Failed to clear dependencies cache'"
    exit 0
fi

if [ "$CLEAR_TOOLS" = true ]; then
    echo "Clearing toolchains, sources, and dependencies..."
    run_in_container "
        echo 'Clearing sources cache...'
        sudo rm -rf /build/sources/*
        echo 'Clearing toolchains cache...'
        sudo rm -rf /build/toolchains/*
        sudo rm -rf /build/toolchains-musl/*
        sudo rm -rf /build/toolchains-glibc/*
        echo 'Clearing dependencies cache...'
        sudo rm -rf /build/deps-cache/*
        echo '✓ Cleared all caches (sources, toolchains, dependencies)'
    "
    exit 0
fi

if [ "$INTERACTIVE" = true ]; then
    echo "Starting interactive shell in build container..."
    echo "=============================================="
    echo "You are now in the Sthenos build environment"
    echo "Build directory: /build"
    echo "Sources cache: /build/sources"
    echo "Toolchains cache: /build/toolchains"
    echo "=============================================="
    run_in_container "" true
fi

if [ "$SHELL_CMD" = true ]; then
    run_in_container "$SHELL_COMMAND"
fi

if [ "$DOWNLOAD_ONLY" = true ]; then
    echo "Download-only mode: fetching sources and toolchains..."
    echo "Would download sources to: $(pwd)/sources/"
    echo "Would download toolchains to: $(pwd)/toolchains/"
    echo "Note: Actual download happens inside Docker during build"
    exit 0
fi

if [ "$SHAREDLIB_MODE" = true ]; then
    echo "Building shared library: $SHAREDLIB_NAME"
    
    # If no LIBC_TYPE specified, build-shared.sh will handle building both
    run_in_container "
        source /build/scripts/lib/toolchain_manager.sh
        # Only export LIBC_TYPE if explicitly set
        ${LIBC_TYPE:+export LIBC_TYPE=$LIBC_TYPE}
        $DEBUG_CMD /build/scripts/shared/build-shared.sh $SHAREDLIB_NAME $ARCHITECTURES
    "
fi

if ! docker image inspect sthenos-builder >/dev/null 2>&1; then
    echo "Building Docker image..."
    docker build -t sthenos-builder .
fi

if [ -n "$DEBUG" ]; then
    DEBUG_FLAGS="-e DEBUG=1"
    DEBUG_CMD="bash -x"
else
    DEBUG_FLAGS=""
    DEBUG_CMD=""
fi

# LIBC_TYPE is left unset unless explicitly specified via --libc flag
# or when building custom-glibc tool
if [ "$TOOLS" = "custom-glibc" ]; then
    LIBC_TYPE="glibc"
fi


if [ "$ARCHITECTURES" != "all" ]; then
    IFS=',' read -ra ARCH_ARRAY <<< "$ARCHITECTURES"
    for arch in "${ARCH_ARRAY[@]}"; do
        if is_glibc_only_arch "$arch"; then
            LIBC_TYPE="glibc"
            break
        fi
    done
fi

DOCKER_IMAGE="sthenos-builder"

if ! docker image inspect $DOCKER_IMAGE >/dev/null 2>&1; then
    echo "Building Docker image..."
    docker build -t $DOCKER_IMAGE .
fi

if [ "$SHAREDLIB_MODE" != true ]; then
    LOG_ENABLED="false"
    if [ -z "$DEBUG" ]; then
        LOG_ENABLED="true"
    fi
    
    MODE="${BUILD_MODE:-standard}"
    
    BUILD_SHARED="false"
    if [ "$NO_SHARED" != true ] && [ "$TOOLS" = "all" ]; then
        BUILD_SHARED="true"
    fi
    
    run_in_container "
        source /build/scripts/lib/toolchain_manager.sh
        source /build/scripts/static/build-static.sh

        # If LIBC_TYPE is set, use it directly
        # Otherwise default to musl (the original behavior)
        if [ -n '$LIBC_TYPE' ]; then
            run_static_builds '$TOOLS' '$ARCHITECTURES' '$LIBC_TYPE' '$MODE' '$LOG_ENABLED' '$DEBUG'
        else
            # Default to musl when no --libc specified
            run_static_builds '$TOOLS' '$ARCHITECTURES' 'musl' '$MODE' '$LOG_ENABLED' '$DEBUG'
        fi
        
        if [ '$BUILD_SHARED' = 'true' ]; then
            echo ''
            echo 'Building shared libraries...'
            echo '=============================='
            
            SHARED_LIBS='libshells libtlsnoverify libdesock libcustom'
            
            # Don't set LIBC_TYPE - let build-shared.sh handle both
            export LOG_ENABLED='$LOG_ENABLED'
            export DEBUG='$DEBUG'
            $DEBUG_CMD /build/scripts/shared/build-shared.sh \$SHARED_LIBS '$ARCHITECTURES'
        fi
    "
fi

